from __future__ import print_function
from __future__ import division
import binascii
import sys


# Verify that what's passed in is actually a PKCS #1 signature.
def VerifyPKCS1(signature, modulus):
    signature = pow(signature, 65537, modulus)

    if (signature >> (2048 - 16)) != 0x0001:
        return False
    if (signature >> 416) != ((1 << (2048 - 16 - 416 + 1)) - 1):
        print("meow %0512X" % (signature >> 416))
        return False
    if ((signature >> 408) & 0xFF) != 0x00:
        print("hiss")
        return False
    return True


def PrintWordDefines(name, number):
    for i in xrange(64):
        n = (number >> (i * 32)) % (1 << 32)
        print('#define %s_%02d "0x%08XU"' % (name, i, n))


def PrintNumberString(name, number):
    print("const char " + name + "[] =");
    lines = []
    for i in xrange(8):
        lines += [ '\t"%064X"' % (number % (1 << (32 * 8))) ]
        number >>= 32 * 8
    lines = lines[::-1]
    lines[len(lines) - 1] += ";"
    for line in lines:
        print(line)


def PrintInfo(modbytes, sigbytes):
    # Parse input.
    have_sig = sigbytes != None

    modulus = int(binascii.hexlify(modbytes), 16)

    if have_sig:
        root = int(binascii.hexlify(sigbytes), 16)
        assert VerifyPKCS1(root, modulus)
    else:
        root = int(binascii.hexlify(b"MEOW" * 64), 16)

    # Calculate other necessary numbers.
    R = 1 << 2048
    Rmod = R % modulus

    block = pow(root, 65537, modulus)

    blockR = (block * R) % modulus
    
    # Cheeseball trick to get a modulus inverse mod R.
    # Based on Euler's lemma and the fact that all possible orders mod R are
    # powers of 2.
    modinv = pow(modulus, R - 1, R)
    assert((modulus * modinv) % R == 1)

    negmodinv = R - modinv
    negmodinvword = negmodinv % (1 << 32)
    
    # Write output.
    print("// Automatically generated by CreateModulusHeader.py.")
    print("#pragma once")
    print("")
    print("// Public exponent.")
    print("const unsigned long s_publicExponent = 65537;")
    print("")
    print("// Modulus.")
    PrintNumberString("s_modulus", modulus)
    print("")

    if have_sig:
        print("// A valid PKCS #1 signature for this modulus.")
        print("#define SIGNATURE_IS_PKCS1")
    else:
        print("// The 65537th root of s_multiplier.")
    PrintNumberString("s_root", root)

    print("")
    print("// s_root to the 65537th power.")
    PrintNumberString("s_multiplier", block)
    print("")
    print("// s_multiplier in Montgomery form (i.e., times R).")
    PrintNumberString("s_multiplierMontgomery", blockR)

    print("")
    print("// The 32-bit parts of s_modulus, least-significant first.")
    PrintWordDefines("MODULUS_WORD", modulus)
    print("")
    print("// The low 32 bits of R - (modulus^-1) mod R.")
    print('#define MODULUS_INVERSE_LOW "0x%08X"' % negmodinvword)
    print("")
    print("// The 32-bit parts of s_multiplierMontgomery, least-significant first.")
    PrintWordDefines("MULTIPLIER_WORD", blockR)


def main(argv):
    if len(argv) != 2 or argv[1] == "--help":
        print("Pass in a 256-byte or 512-byte file.")
        print("The first 256 bytes are the big-endian modulus.")
        print("The second 256 bytes, if given, are a valid signature.")
        return 1

    handle = open(argv[1], "rb")
    data = handle.read(513)
    handle.close()

    if (len(data) != 512) and (len(data) != 256):
        print("File is not a valid size")
        return 1

    modbytes = data[0:256]
    if len(data) == 512:
        sigbytes = data[256:512]
    else:
        sigbytes = None

    return PrintInfo(modbytes, sigbytes)


if __name__ == "__main__":
    sys.exit(main(sys.argv))
